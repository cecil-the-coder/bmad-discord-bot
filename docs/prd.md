# BMAD Knowledge Bot Product Requirements Document (PRD)

## Goals and Background Context

### Goals

* Increase the adoption and effective, consistent use of the BMAD-METHOD framework.
* Allow users to get accurate, helpful answers to their questions about BMAD-METHOD in under 30 seconds.
* Provide a specialized Discord bot that answers questions exclusively from the BMAD knowledge base.
* Provide a real-time visual indicator of the bot's API rate-limit status via its Discord status.
* Enable conversational follow-up questions within Discord threads while maintaining BMAD context.

### Background Context

The core problem this project addresses is the inefficiency developers face when searching through large BMAD documentation files. This manual process disrupts workflow and can lead to inconsistent application of the framework.

The proposed solution is a Golang-based Discord bot that acts as a specialized BMAD-METHOD expert. It will use the Gemini CLI to query exclusively from the BMAD knowledge base and provide synthesized, conversational answers within Discord threads, allowing for context-aware follow-up questions. The bot will maintain citations to the source documentation and refuse to answer questions outside the BMAD scope. The entire application will be containerized for portable deployment.

### Change Log

| Date | Version | Description | Author |
| :--- | :--- | :--- | :--- |
| 2025-06-28 | 1.0 | Initial PRD creation | John, PM |

## Requirements

### Functional

* **FR1**: The bot must successfully connect to the Discord API using a bot token and maintain a persistent online presence.
* **FR2**: The bot must detect and trigger a response workflow when it is @-mentioned in a message.
* **FR3**: On the first reply to a user's query, the bot must create a new public Discord Thread.
* **FR4**: When mentioned within an existing thread it created, the bot must read the preceding messages in that thread to establish conversational context.
* **FR5**: The backend service must be able to receive the user's latest question along with the summarized conversation history from a thread.
* **FR6**: The backend service will execute the Gemini CLI, providing it with the necessary context and the user's new question to generate a relevant answer.
* **FR7**: The bot must post the answer generated by the CLI back into the appropriate Discord thread.
* **FR8**: The bot must internally monitor its usage of the Gemini API to track its proximity to the rate limit.
* **FR9**: The bot's Discord presence status (Online, Idle, Do Not Disturb) must be updated automatically to reflect its current API usage status.

### Non Functional

* **NFR1**: The backend service will be developed in Golang.
* **NFR2**: The final application must be containerized using Docker for deployment.
* **NFR3**: The architecture must decouple the core application logic from the AI interaction service, allowing the Gemini CLI to be replaced by other methods in the future.
* **NFR4**: The system must respect and handle the Gemini API's rate limits to avoid being throttled.
* **NFR5**: The median response time, from user question to bot answer, should be under 10 seconds.

## Technical Assumptions

* **Repository Structure**: A single **Polyrepo** will be used for the bot's codebase.
* **Service Architecture**: We will proceed with a **Monolithic service** for the MVP.
* **Testing requirements**: The project requires **Unit Tests** for all core logic and **Integration Tests** for the connection to the Discord API and the Gemini CLI wrapper.
* **Additional Technical Assumptions and Requests**:
    * The backend service must be written in **Golang**.
    * The application must be containerized with **Docker** for deployment.

## Implementation Decisions

* **Knowledge Base Storage**: The BMAD knowledge base (`bmadprompt.md`) is stored in `internal/knowledge/bmad.md` and included directly in the Docker image. This eliminates the need to mount external volumes and ensures the knowledge base is always available with the deployed application.

## Epics

### Epic 1: Core Conversational Bot

**Goal**: Establish a production-ready Discord bot that can answer user questions with conversational context within threads and proactively report on its API health.

#### Story 1.1: Basic Bot Setup and Connection

As a server administrator, I want to set up the bot project and see it connect to Discord, so that I can confirm the basic infrastructure is working.

* **Acceptance Criteria**:
    * 1.1.1: A new Go project/module is initialized.
    * 1.1.2: The project includes a dependency for a Discord API library (e.g., `discordgo`).
    * 1.1.3: The application can read a bot token from an environment variable.
    * 1.1.4: When the application is run, the bot successfully connects to the Discord Gateway and appears as "Online" in the server.

#### Story 1.2: Simple Mention-and-Reply Functionality

As a user, I want to mention the bot with a question and get a simple answer, so that I can validate the core question-answering workflow.

* **Acceptance Criteria**:
    * 1.2.1: When the bot is @-mentioned with a text query, the content of the query is captured by the backend.
    * 1.2.2: The backend service has a wrapper function that executes the Gemini CLI with the user's query.
    * 1.2.3: The text output from the Gemini CLI is captured by the backend service.
    * 1.2.4: The bot replies directly to the user's message with the complete, unformatted text from the Gemini CLI.
    * 1.2.5: This interaction does not yet use or create threads.

#### Story 1.3: Threaded Conversation Creation

As a user, when I ask the bot a question, I want it to create a new thread for the answer, so that our conversation is neatly organized and doesn't clutter the main channel.

* **Acceptance Criteria**:
    * 1.3.1: When the bot replies to a user's initial @-mention (that is not already in a thread), it must create a new public Discord Thread.
    * 1.3.2: The thread title should be a summarized version of the user's initial question.
    * 1.3.3: The bot's answer (from Story 1.2 functionality) is posted as the first message within the newly created thread.

#### Story 1.4: Implement Conversational Context in Threads

As a user, I want to ask follow-up questions within a thread and have the bot understand the context of our conversation, so that I can have a more natural and helpful interaction.

* **Acceptance Criteria**:
    * 1.4.1: When the bot is @-mentioned within a thread it created, it must fetch the message history of that thread.
    * 1.4.2: The backend service must have a function to summarize the conversation history.
    * 1.4.3: The prompt sent to the Gemini CLI must include both the summarized history and the user's new question.
    * 1.4.4: The bot's new answer is posted as a reply within the same thread.

#### Story 1.5: API Usage Monitoring

As the bot operator, I want the application to internally track its usage of the Gemini API, so that it can operate reliably without being rate-limited.

* **Acceptance Criteria**:
    * 1.5.1: The backend service must maintain an internal counter for Gemini API calls.
    * 1.5.2: The counter should track usage over a configurable time window (e.g., requests per minute).
    * 1.5.3: The system exposes an internal state representing the current usage level (e.g., Normal, Warning, Throttled).

#### Story 1.6: Dynamic Bot Status for API Health

As a user, I want to see the bot's Discord status change color, so that I have a quick visual indicator of its current API capacity and health.

* **Acceptance Criteria**:
    * 1.6.1: The bot's presence/status on Discord is updated based on the internal API usage monitor from Story 1.5.
    * 1.6.2: When API usage is low, the status is set to "Online" (Green).
    * 1.6.3: When API usage is approaching the rate limit (e.g., >75% capacity), the status is set to "Idle" (Yellow).
    * 1.6.4: If the rate limit has been exceeded, the status is set to "Do Not Disturb" (Red).
    * 1.6.5: The status returns to normal once the usage level drops.